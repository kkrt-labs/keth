import pytest
from ethereum_types.numeric import U256
from hypothesis import given

from ethereum.cancun.vm.exceptions import ExceptionalHalt
from ethereum.cancun.vm.instructions.control_flow import (
    gas_left,
    jump,
    jumpdest,
    jumpi,
    pc,
    stop,
)
from ethereum.cancun.vm.stack import push
from tests.utils.args_gen import Evm
from tests.utils.evm_builder import EvmBuilder

pytestmark = pytest.mark.python_vm


class TestControlFlow:
    @given(evm=EvmBuilder().with_running().build())
    def test_stop(self, cairo_run, evm: Evm):
        try:
            cairo_result = cairo_run("stop", evm)
        except ExceptionalHalt as cairo_error:
            with pytest.raises(type(cairo_error)):
                stop(evm)
            return

        stop(evm)
        assert evm == cairo_result

    @given(
        evm=EvmBuilder()
        .with_stack()
        .with_gas_left()
        .with_valid_jump_destinations()
        .build(),
        push_valid_jump_destination=...,
    )
    def test_jump(self, cairo_run, evm: Evm, push_valid_jump_destination: bool):
        # Modify the stack to match the valid_jump_destinations generated by hypothesis
        jump_dest = (
            next(iter(evm.valid_jump_destinations))
            if push_valid_jump_destination and evm.valid_jump_destinations
            else 0
        )
        push(evm.stack, U256(jump_dest))

        try:
            cairo_result = cairo_run("jump", evm)
        except ExceptionalHalt as cairo_error:
            with pytest.raises(type(cairo_error)):
                jump(evm)
            return

        jump(evm)
        assert evm == cairo_result

    @given(
        evm=EvmBuilder()
        .with_stack()
        .with_gas_left()
        .with_valid_jump_destinations()
        .build(),
        push_valid_jump_destination=...,
        jumpi_condition=...,
    )
    def test_jumpi(
        self,
        cairo_run,
        evm: Evm,
        push_valid_jump_destination: bool,
        jumpi_condition: bool,
    ):
        # Modify the stack to match the valid_jump_destinations generated by hypothesis
        push(evm.stack, U256(jumpi_condition))
        jump_dest = (
            next(iter(evm.valid_jump_destinations))
            if push_valid_jump_destination and evm.valid_jump_destinations
            else 0
        )
        push(evm.stack, U256(jump_dest))

        try:
            cairo_result = cairo_run("jumpi", evm)
        except ExceptionalHalt as cairo_error:
            with pytest.raises(type(cairo_error)):
                jumpi(evm)
            return

        jumpi(evm)
        assert evm == cairo_result

    @given(evm=EvmBuilder().with_gas_left().with_pc().build())
    def test_pc(self, cairo_run, evm: Evm):
        try:
            cairo_result = cairo_run("pc", evm)
        except ExceptionalHalt as cairo_error:
            with pytest.raises(type(cairo_error)):
                pc(evm)
            return

        pc(evm)
        assert evm == cairo_result

    @given(evm=EvmBuilder().with_gas_left().build())
    def test_gas_left(self, cairo_run, evm: Evm):
        try:
            cairo_result = cairo_run("gas_left", evm)
        except ExceptionalHalt as cairo_error:
            with pytest.raises(type(cairo_error)):
                gas_left(evm)
            return

        gas_left(evm)
        assert evm == cairo_result

    @given(evm=EvmBuilder().with_gas_left().build())
    def test_jumpdest(self, cairo_run, evm: Evm):
        try:
            cairo_result = cairo_run("jumpdest", evm)
        except ExceptionalHalt as cairo_error:
            with pytest.raises(type(cairo_error)):
                jumpdest(evm)
            return

        jumpdest(evm)
        assert evm == cairo_result
