%builtins output pedersen range_check ecdsa bitwise ec_op keccak poseidon range_check96 add_mod mul_mod
// In proof mode running with RustVM requires declaring all builtins of the layout and taking them as entrypoint
// see: <https://github.com/lambdaclass/cairo-vm/issues/2004>

from starkware.cairo.common.cairo_builtins import (
    BitwiseBuiltin,
    KeccakBuiltin,
    PoseidonBuiltin,
    ModBuiltin,
    HashBuiltin,
    SignatureBuiltin,
    EcOpBuiltin,
)
from ethereum.cancun.fork import state_transition, BlockChain, Block, keccak256_header
from ethereum_types.bytes import Bytes32

from mpt.hash_diff import (
    hash_state_storage_diff,
    hash_state_account_diff,
    hash_account_diff_segment,
    hash_storage_diff_segment,
)
from mpt.types import (
    NodeStore,
    OptionalUnionInternalNodeExtended,
    MappingBytes32Bytes32,
    MappingBytes32Address,
)
from mpt.trie_diff import compute_diff_entrypoint
from mpt.utils import sort_account_diff, sort_storage_diff

func main{
    output_ptr: felt*,
    pedersen_ptr: HashBuiltin*,
    range_check_ptr,
    ecdsa_ptr: SignatureBuiltin*,
    bitwise_ptr: BitwiseBuiltin*,
    ec_op_ptr: EcOpBuiltin*,
    keccak_ptr: KeccakBuiltin*,
    poseidon_ptr: PoseidonBuiltin*,
    range_check96_ptr: felt*,
    add_mod_ptr: ModBuiltin*,
    mul_mod_ptr: ModBuiltin*,
}() {
    alloc_locals;

    local chain: BlockChain;
    local block: Block;
    %{
        from ethereum.cancun.fork import BlockChain, Block
        from ethereum_types.bytes import Bytes32

        ids.chain = gen_arg(BlockChain, program_inputs["blockchain"])
        ids.block = gen_arg(Block, program_inputs["block"])
    %}

    let parent_header = chain.value.blocks.value.data[
        chain.value.blocks.value.len - 1
    ].value.header;
    let pre_state_root = parent_header.value.state_root;
    let post_state_root = block.value.header.value.state_root;

    state_transition{chain=chain}(block);

    let block_hash = keccak256_header(block.value.header);

    // Commitment part: we commit to the state diffs generated by the state transition.
    let state = chain.value.state;
    let state_account_diff_commitment = hash_state_account_diff(state);
    let state_storage_diff_commitment = hash_state_storage_diff(state);

    // Trie Diff part: we compute the difference between the pre and post STF MPTs.
    local node_store: NodeStore;
    local address_preimages: MappingBytes32Address;
    local storage_key_preimages: MappingBytes32Bytes32;
    local left: OptionalUnionInternalNodeExtended;
    local right: OptionalUnionInternalNodeExtended;
    %{
        from ethereum.crypto.hash import Hash32
        from ethereum.cancun.fork_types import Address
        from ethereum_types.bytes import Bytes32, Bytes
        from ethereum.cancun.trie import InternalNode
        from typing import Mapping, Optional, Union
        from ethereum_rlp import Extended

        ids.node_store = gen_arg(Mapping[Hash32, InternalNode], program_inputs["node_store"])
        ids.address_preimages = gen_arg(Mapping[Hash32, Address], program_inputs["address_preimages"])
        ids.storage_key_preimages = gen_arg(Mapping[Hash32, Bytes32], program_inputs["storage_key_preimages"])
        ids.left = gen_arg(Optional[
            Union[InternalNode, Extended]
        ], program_inputs["pre_state_root"])
        ids.right = gen_arg(Optional[
            Union[InternalNode, Extended]
        ], program_inputs["post_state_root"])
    %}
    let (account_diff, storage_diff) = compute_diff_entrypoint(
        node_store=node_store,
        address_preimages=address_preimages,
        storage_key_preimages=storage_key_preimages,
        left=left,
        right=right,
    );
    let account_diff = sort_account_diff(account_diff);
    let storage_diff = sort_storage_diff(storage_diff);
    let trie_account_diff_commitment = hash_account_diff_segment(account_diff);
    let trie_storage_diff_commitment = hash_storage_diff_segment(storage_diff);

    assert state_account_diff_commitment = trie_account_diff_commitment;
    assert state_storage_diff_commitment = trie_storage_diff_commitment;

    assert [output_ptr] = pre_state_root.value.low;
    assert [output_ptr + 1] = pre_state_root.value.high;
    assert [output_ptr + 2] = post_state_root.value.low;
    assert [output_ptr + 3] = post_state_root.value.high;
    assert [output_ptr + 4] = block_hash.value.low;
    assert [output_ptr + 5] = block_hash.value.high;
    // we commit to the state diffs by hashing the storage and account diffs collectively.
    // TODO: in this program or another, assert that the account commitments
    // generated by the state transition match the ones computed between the pre and post MPTs.
    assert [output_ptr + 6] = account_diff_commitment;
    assert [output_ptr + 7] = storage_diff_commitment;

    let output_ptr = output_ptr + 8;
    return ();
}
